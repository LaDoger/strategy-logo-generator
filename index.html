<!DOCTYPE html>
<html>
<head>
    <title>Strategy Logo Maker</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="og:title" content="Strategy Logo Maker">
    <meta property="og:description" content="Strategy Logo Makers made by @LaDoger21">
    <meta property="og:type" content="gallery">
    <meta property="og:url" content="https://ladoger.art/logomaker">
    <meta property="og:image" content="https://ladoger.art/logomaker/logomaker.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="600">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Strategy Logo Maker">
    <meta name="twitter:description" content="Strategy Logo Maker made by @LaDoger21">
    <meta name="twitter:image" content="https://ladoger.art/logomaker/logomaker.jpg">
    <meta name="twitter:site" content="@LaDoger21">

    <style>
        body {
            display: flex; flex-direction: column; align-items: center;
            font-family: 'Lexend', sans-serif; margin: 0; padding: 20px 20px 0;
            min-height: 100vh; box-sizing: border-box; background-color: #FFFFFF;
        }
        .container {
            width: 100%; max-width: 800px; display: flex; flex-direction: column;
            align-items: center; gap: 15px; flex-grow: 1;
        }
        h2 {
            font-size: 2.5em; font-weight: 700; margin: 0; color: #FA660F;
            letter-spacing: -0.1em; padding-bottom: 5px;
        }
        input[type="text"] {
            width: 100%; max-width: 300px; padding: 10px; font-size: 16px;
            font-family: 'Lexend', sans-serif; font-weight: 400; box-sizing: border-box;
            border: 3px solid transparent; border-radius: 8px;
            background: linear-gradient(#FFFFFF, #FFFFFF) padding-box,
                        linear-gradient(to right, #FFB6C1, #FFDAB9, #FFDEAD, #E6E6FA, #B0E0E6, #98FB98, #D8BFD8) border-box;
            animation: gradientShift 8s linear infinite; background-size: 100% 100%, 200% 100%;
            text-align: center;
        }
        @keyframes gradientShift { 0% { background-position: 0% 0%; } 100% { background-position: 200% 0%; } }

        .color-picker-container {
            display: flex; justify-content: space-around; align-items: center;
            width: 100%; max-width: 300px; margin-top: 5px; margin-bottom: 10px;
            padding: 8px 15px; background-color: #f8f8f8; border: 1px solid #eee;
            border-radius: 8px; box-sizing: border-box;
        }
        input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none; /* Remove default styling */
            width: 40px; height: 40px; padding: 0; border: none; border-radius: 6px;
            cursor: pointer; background-color: transparent; border: 1px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease-in-out;
        }
        input[type="color"]:hover { transform: scale(1.05); }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; border-radius: 6px; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 6px; }
        input[type="color"]::-moz-color-swatch { border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 6px; }

        .canvas-row { display: flex; flex-wrap: nowrap; gap: 10px; width: 100%; max-width: 800px; }
        canvas { width: 390px; height: auto; border: 1px solid #ccc; }
        .transparent-bg {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        footer { width: 100%; text-align: center; padding: 10px 0; background-color: #FFFFFF; font-weight: 400; margin-top: 10px; }
        footer a { color: #FA660F; text-decoration: none; }
        footer a b { font-weight: 700; }
        footer a:hover { text-decoration: underline; }

        @media (max-width: 600px) {
            .canvas-row { flex-direction: column; gap: 10px; }
            canvas { width: 100% !important; max-width: 100%; cursor: pointer; }
            h2 { font-size: 1.8em; }
            input[type="text"], .color-picker-container { max-width: 100%; }
            .color-picker-container { padding: 8px 10px; }
            input[type="color"] { width: 35px; height: 35px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Strategy Logo Maker</h2>

        <input type="text" id="wordInput" value="More" placeholder="Enter text..." oninput="generateLogos()">

        <div class="color-picker-container">
            <input type="color" id="colorPicker1" value="#000000" title="Color 1" oninput="generateLogos()">
            <input type="color" id="colorPicker2" value="#FFFFFF" title="Color 2" oninput="generateLogos()">
            <input type="color" id="colorPicker3" value="#FA660F" title="Color 3" oninput="generateLogos()">
        </div>

        <!-- Canvas Rows -->
        <div class="canvas-row">
            <canvas id="canvas1" width="1280" height="720"></canvas>
            <canvas id="canvas4" width="1280" height="720" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas2" width="1280" height="720"></canvas>
            <canvas id="canvas5" width="1280" height="720" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas3" width="1280" height="720"></canvas>
            <canvas id="canvas6" width="1280" height="720" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas7" width="1280" height="1280"></canvas>
            <canvas id="canvas10" width="1280" height="1280" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas8" width="1280" height="1280"></canvas>
            <canvas id="canvas11" width="1280" height="1280" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas9" width="1280" height="1280"></canvas>
            <canvas id="canvas12" width="1280" height="1280" class="transparent-bg"></canvas>
        </div>
    </div>
    <footer>
        Made by <a href="https://x.com/LaDoger21"><b>@LaDoger21</b></a> with ðŸ§¡
    </footer>

    <script>
        const COLOR_ROLE_1 = 'color1';
        const COLOR_ROLE_2 = 'color2';
        const COLOR_ROLE_3 = 'color3';

        const canvases = [
            // Role pairs define text/background combinations
            { id: 'canvas1', textColorRole: COLOR_ROLE_1, bgColorRole: COLOR_ROLE_3 }, { id: 'canvas4', textColorRole: COLOR_ROLE_1, bgColorRole: 'transparent' },
            { id: 'canvas2', textColorRole: COLOR_ROLE_3, bgColorRole: COLOR_ROLE_2 }, { id: 'canvas5', textColorRole: COLOR_ROLE_3, bgColorRole: 'transparent' },
            { id: 'canvas3', textColorRole: COLOR_ROLE_2, bgColorRole: COLOR_ROLE_1 }, { id: 'canvas6', textColorRole: COLOR_ROLE_2, bgColorRole: 'transparent' },
            // Square versions
            { id: 'canvas7', textColorRole: COLOR_ROLE_1, bgColorRole: COLOR_ROLE_3 }, { id: 'canvas10', textColorRole: COLOR_ROLE_1, bgColorRole: 'transparent' },
            { id: 'canvas8', textColorRole: COLOR_ROLE_3, bgColorRole: COLOR_ROLE_2 }, { id: 'canvas11', textColorRole: COLOR_ROLE_3, bgColorRole: 'transparent' },
            { id: 'canvas9', textColorRole: COLOR_ROLE_2, bgColorRole: COLOR_ROLE_1 }, { id: 'canvas12', textColorRole: COLOR_ROLE_2, bgColorRole: 'transparent' }
        ];

        // Load the single symbol image
        const symbolImg = new Image();
        symbolImg.src = 'symbol.png'; // Updated filename
        let symbolLoaded = false;
        symbolImg.onload = () => {
            symbolLoaded = true;
            if (window.initialDrawTriggered) { // If initial draw was waiting for the image
                generateLogos();
            }
        };
         symbolImg.onerror = () => console.error("Failed to load symbol image: symbol.png");

        // Reusable offscreen canvas for symbol colorization
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        function getSelectedColors() {
            return {
                [COLOR_ROLE_1]: document.getElementById('colorPicker1').value,
                [COLOR_ROLE_2]: document.getElementById('colorPicker2').value,
                [COLOR_ROLE_3]: document.getElementById('colorPicker3').value
            };
        }

        function drawColorizedSymbol(mainCtx, targetColor, symbolX, symbolY, symbolWidth, symbolHeight) {
            if (!symbolLoaded || symbolWidth <= 0 || symbolHeight <= 0) return;
            try {
                offscreenCanvas.width = symbolWidth;
                offscreenCanvas.height = symbolHeight;
                offscreenCtx.clearRect(0, 0, symbolWidth, symbolHeight);
                offscreenCtx.drawImage(symbolImg, 0, 0, symbolWidth, symbolHeight); // Draw symbol
                offscreenCtx.globalCompositeOperation = 'source-in'; // Keep only symbol pixels
                offscreenCtx.fillStyle = targetColor;
                offscreenCtx.fillRect(0, 0, symbolWidth, symbolHeight); // Fill with target color
                offscreenCtx.globalCompositeOperation = 'source-over'; // Reset
                mainCtx.drawImage(offscreenCanvas, symbolX, symbolY, symbolWidth, symbolHeight); // Draw to main canvas
            } catch (e) {
                console.error("Error drawing colorized symbol:", e);
            }
        }

        function generateLogos() {
            if (!symbolLoaded && !symbolImg.complete) {
                console.log("Symbol not loaded yet, deferring generateLogos.");
                // Ensure initial draw triggers this again once loaded
                window.initialDrawTriggered = true;
                return;
            }

            requestAnimationFrame(() => {
                const input = document.getElementById('wordInput').value;
                const word = input ? input + "  " : ""; // Add spacing for symbol
                const selectedColors = getSelectedColors();

                canvases.forEach(canvasInfo => {
                    const canvas = document.getElementById(canvasInfo.id);
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    const textColor = selectedColors[canvasInfo.textColorRole];
                    const bgColor = canvasInfo.bgColorRole === 'transparent' ? 'transparent' : selectedColors[canvasInfo.bgColorRole];

                    // Clear and set background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (bgColor !== 'transparent') {
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    if (word) {
                        // --- Font Size Calculation ---
                        const maxWidth = canvas.width * 0.9;
                        const maxHeight = canvas.height * 0.9;
                        let fontSize = Math.min(canvas.width / 5, canvas.height / 1.5); // Initial guess
                        ctx.font = `bold ${fontSize}px Lexend`;
                        ctx.letterSpacing = `${fontSize * -0.1}px`;
                        let metrics = ctx.measureText(word);
                        let textWidth = metrics.width;
                        let textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent || fontSize;
                        let iterations = 0; const maxIterations = 50;

                        // Adjust size iteratively
                        while (((textWidth > maxWidth) || (textHeight > maxHeight)) && fontSize > 10 && iterations < maxIterations) { // Scale down
                            let scaleFactor = Math.min(maxWidth / textWidth, maxHeight / textHeight);
                            fontSize *= scaleFactor * 0.97; // Slightly more aggressive scale down
                            fontSize = Math.max(fontSize, 10);
                            ctx.font = `bold ${fontSize}px Lexend`; ctx.letterSpacing = `${fontSize * -0.1}px`;
                            metrics = ctx.measureText(word); textWidth = metrics.width; textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent || fontSize;
                            iterations++;
                        }
                        iterations = 0;
                        while (textWidth < maxWidth * 0.8 && textHeight < maxHeight * 0.8 && fontSize < Math.min(canvas.width, canvas.height) && iterations < maxIterations) { // Scale up
                             let scaleFactor = Math.min(maxWidth / textWidth, maxHeight / textHeight); if (scaleFactor <= 1.01) break;
                             fontSize *= Math.min(scaleFactor, 1.02); // Slightly less aggressive scale up
                             fontSize = Math.min(fontSize, Math.min(canvas.width, canvas.height));
                             ctx.font = `bold ${fontSize}px Lexend`; ctx.letterSpacing = `${fontSize * -0.1}px`;
                             metrics = ctx.measureText(word); textWidth = metrics.width; textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent || fontSize;
                             iterations++;
                         }
                         if (textWidth > maxWidth || textHeight > maxHeight) { // Final check
                             fontSize *= Math.min(maxWidth / textWidth, maxHeight / textHeight); fontSize = Math.max(fontSize, 10);
                             ctx.font = `bold ${fontSize}px Lexend`; ctx.letterSpacing = `${fontSize * -0.1}px`; metrics = ctx.measureText(word); textWidth = metrics.width;
                         }
                        // --- End Font Size Calculation ---

                        // Draw Text
                        ctx.fillStyle = textColor;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textY = canvas.height / 2;
                        ctx.fillText(word, canvas.width / 2, textY);

                        // Draw Symbol
                        const symbolHeight = fontSize * 0.6;
                        const symbolAspectRatio = 534 / 889; // Aspect ratio of symbol.png
                        const symbolWidth = symbolHeight * symbolAspectRatio;
                        const inputMetrics = ctx.measureText(input); // Measure text *without* spaces
                        const inputWidth = inputMetrics.width;
                        const symbolX = (canvas.width / 2) + (inputWidth / 2) - (fontSize * 0.12); // Position relative to text end
                        const downwardShiftFactor = 0.08;
                        const symbolBottomY = textY + (fontSize * downwardShiftFactor);
                        const symbolY = symbolBottomY - symbolHeight;

                        drawColorizedSymbol(ctx, textColor, symbolX, symbolY, symbolWidth, symbolHeight);
                    }
                });
            });
        }

        function setupCanvasClickEvents() {
             canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) return;
                canvas.onclick = null; // Clear previous handler

                if (isMobile) {
                    canvas.onclick = () => {
                        const dataUrl = canvas.toDataURL('image/png');
                        const word = document.getElementById('wordInput').value || 'Logo';
                        const aspectRatio = canvas.width === canvas.height ? 'square' : '16x9';
                        const selectedColors = getSelectedColors();
                        const textColor = selectedColors[canvasInfo.textColorRole];
                        const bgColor = canvasInfo.bgColorRole === 'transparent' ? 'transparent' : selectedColors[canvasInfo.bgColorRole];
                        const filename = `${word}_${textColor}_on_${bgColor}_${aspectRatio}.png`.replace(/#/g,''); // Remove '#' for cleaner filename

                        // iOS Share / Save Fallback
                        if (isIOS && navigator.share) {
                           try {
                                fetch(dataUrl).then(res => res.blob()).then(blob => {
                                    if (!blob) throw new Error("Blob creation failed");
                                    navigator.share({ files: [new File([blob], filename, { type: 'image/png' })], title: filename })
                                     .catch(() => window.open(dataUrl, '_blank').document.write(`<img src="${dataUrl}" alt="Press/hold image"><p>Press/hold image to save.</p>`)); // Fallback on share error
                                }).catch(() => window.open(dataUrl, '_blank').document.write(`<img src="${dataUrl}" alt="Press/hold image"><p>Press/hold image to save.</p>`)); // Fallback on fetch/blob error
                           } catch (error) { window.open(dataUrl, '_blank').document.write(`<img src="${dataUrl}" alt="Press/hold image"><p>Press/hold image to save.</p>`); } // Fallback on general error
                        } else if (isIOS) { // iOS without Share API
                            const imageWindow = window.open(dataUrl, '_blank'); // Open directly
                            // Attempt to add instructions, might not work reliably in all iOS scenarios
                            setTimeout(() => { if(imageWindow) imageWindow.document.body.innerHTML = `<img src="${dataUrl}" alt="Press/hold image"><p>Press/hold image to save.</p>`; }, 500);
                        } else { // Standard Download
                            const link = document.createElement('a'); link.download = filename; link.href = dataUrl;
                            document.body.appendChild(link); link.click(); document.body.removeChild(link);
                        }
                    };
                }
            });
        }

        function resizeCanvases() {
            const container = document.querySelector('.container');
            const totalWidth = Math.min(800, container.clientWidth); // Use container width up to max 800px
            const gap = 10;
            const isSmallScreen = window.innerWidth <= 600; // Use window width for media query breakpoint check

            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) return;
                const displayWidth = isSmallScreen ? (container.clientWidth) : (totalWidth - gap) / 2; // Use container width on small screens
                const nativeRatio = canvas.height / canvas.width;
                const displayHeight = displayWidth * nativeRatio;
                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;
            });
            generateLogos(); // Redraw after resizing
        }

        // Initial Setup on Load
        window.initialDrawTriggered = false;
        window.addEventListener('load', () => {
            // Check if symbol was cached and loaded instantly
            if (symbolImg.complete && symbolImg.naturalWidth > 0) {
                symbolLoaded = true;
            }

            window.initialDrawTriggered = true; // Mark that we want the initial draw
            resizeCanvases(); // Perform initial resize (will call generateLogos, which checks symbolLoaded)
            setupCanvasClickEvents(); // Setup click handlers once

            // Add resize listener
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(resizeCanvases, 100); // Debounce resize events
            });

            // Fallback timeout for symbol loading (less critical now generateLogos checks)
             setTimeout(() => {
                if(!symbolLoaded) {
                    console.warn("Timeout waiting for symbol. Logos might render without it.");
                    symbolLoaded = true; // Allow drawing attempts anyway
                    if(window.initialDrawTriggered) generateLogos(); // Try drawing if needed
                }
             }, 3000);
        });

    </script>
</body>
</html>