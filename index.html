<!DOCTYPE html>
<html>
<head>
    <title>Strategy Logo Maker</title>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Lexend', sans-serif;
            margin: 0;
            padding: 20px 20px 0; /* Top padding is 20px */
            min-height: 100vh;
            box-sizing: border-box;
            background-color: #FFFFFF;
        }
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Reduced from 20px */
            flex-grow: 1;
        }
        h2 {
            font-size: 2.5em;
            font-weight: 700;
            margin: 0;
            color: #FA660F; /* Orange */
            letter-spacing: -0.1em; /* Reduced spacing, matching logo logic */
            padding-bottom: 10px; /* Ensures 20px total spacing to input */
        }
        input {
            width: 100%;
            max-width: 300px;
            padding: 10px;
            font-size: 16px;
            font-family: 'Lexend', sans-serif;
            font-weight: 400; /* Not bold */
            box-sizing: border-box;
            border: 3px solid transparent; /* 3px border with gradient */
            border-radius: 8px; /* Rounded corners */
            background: linear-gradient(#FFFFFF, #FFFFFF) padding-box, /* White background */
                        linear-gradient(to right, #FFB6C1, #FFDAB9, #FFDEAD, #E6E6FA, #B0E0E6, #98FB98, #D8BFD8) border-box;
            animation: gradientShift 8s linear infinite;
        }
        @keyframes gradientShift {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 200% 0%; /* Continuous shift */
            }
        }
        input {
            background-size: 100% 100%, 200% 100%; /* First for white, second for gradient */
        }
        .canvas-row {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px; /* Reduced from 20px */
            width: 100%;
            max-width: 800px;
        }
        canvas {
            /* Dynamic width set by JS, initial width helps layout */
            width: 390px;
            height: auto; /* Height determined by aspect ratio */
            border: 1px solid #ccc;
            /* Display aspect ratio will be set by JS */
        }
        .transparent-bg {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                              linear-gradient(-45deg, #ccc 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #ccc 75%),
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        footer {
            width: 100%;
            text-align: center;
            padding: 10px 0; /* Reduced from 20px */
            background-color: #FFFFFF;
            font-weight: 400; /* Not bold */
            margin-top: 10px; /* Added margin top */
        }
        footer a {
            color: #FA660F; /* Orange */
            text-decoration: none;
        }
        footer a b {
            font-weight: 700; /* Bold for @LaDoger21 */
        }
        footer a:hover {
            text-decoration: underline;
        }
        @media (max-width: 600px) {
            .canvas-row {
                flex-direction: column;
                gap: 10px; /* Reduced from 20px */
            }
            canvas {
                width: 100% !important; /* Override JS width on mobile */
                max-width: 100%;
                cursor: pointer; /* Indicates clickable on mobile */
                 /* Height still determined by JS aspect ratio */
            }
            h2 {
                font-size: 1.8em;
            }
            input {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Strategy Logo Maker</h2>
        <input type="text" id="wordInput" value="Logo" oninput="generateLogos()">

        <!-- Original 16:9 Canvases -->
        <div class="canvas-row">
            <canvas id="canvas1" width="1280" height="720"></canvas> <!-- black on orange -->
            <canvas id="canvas4" width="1280" height="720" class="transparent-bg"></canvas> <!-- black on transparent -->
        </div>
        <div class="canvas-row">
            <canvas id="canvas2" width="1280" height="720"></canvas> <!-- orange on white -->
            <canvas id="canvas5" width="1280" height="720" class="transparent-bg"></canvas> <!-- orange on transparent -->
        </div>
        <div class="canvas-row">
            <canvas id="canvas3" width="1280" height="720"></canvas> <!-- white on black -->
            <canvas id="canvas6" width="1280" height="720" class="transparent-bg"></canvas> <!-- white on transparent -->
        </div>

        <!-- New Square 1:1 Canvases -->
        <div class="canvas-row">
            <canvas id="canvas7" width="1280" height="1280"></canvas> <!-- black on orange (square) -->
            <canvas id="canvas10" width="1280" height="1280" class="transparent-bg"></canvas> <!-- black on transparent (square) -->
        </div>
        <div class="canvas-row">
            <canvas id="canvas8" width="1280" height="1280"></canvas> <!-- orange on white (square) -->
            <canvas id="canvas11" width="1280" height="1280" class="transparent-bg"></canvas> <!-- orange on transparent (square) -->
        </div>
        <div class="canvas-row">
            <canvas id="canvas9" width="1280" height="1280"></canvas> <!-- white on black (square) -->
            <canvas id="canvas12" width="1280" height="1280" class="transparent-bg"></canvas> <!-- white on transparent (square) -->
        </div>

    </div>
    <footer>
        Made by <a href="https://x.com/LaDoger21"><b>@LaDoger21</b></a> with ðŸ§¡
    </footer>

    <script>
        const canvases = [
            // Original 16:9
            { id: 'canvas1', textColor: '#000000', bgColor: '#FA660F', badge: 'blackB.png' },  // black on orange
            { id: 'canvas2', textColor: '#FA660F', bgColor: '#FFFFFF', badge: 'orangeB.png' },  // orange on white
            { id: 'canvas3', textColor: '#FFFFFF', bgColor: '#000000', badge: 'whiteB.png' },  // white on black
            { id: 'canvas4', textColor: '#000000', bgColor: 'transparent', badge: 'blackB.png' },  // black on transparent
            { id: 'canvas5', textColor: '#FA660F', bgColor: 'transparent', badge: 'orangeB.png' },  // orange on transparent
            { id: 'canvas6', textColor: '#FFFFFF', bgColor: 'transparent', badge: 'whiteB.png' },   // white on transparent
            // New 1:1 Square
            { id: 'canvas7', textColor: '#000000', bgColor: '#FA660F', badge: 'blackB.png' },  // black on orange (square)
            { id: 'canvas8', textColor: '#FA660F', bgColor: '#FFFFFF', badge: 'orangeB.png' },  // orange on white (square)
            { id: 'canvas9', textColor: '#FFFFFF', bgColor: '#000000', badge: 'whiteB.png' },  // white on black (square)
            { id: 'canvas10', textColor: '#000000', bgColor: 'transparent', badge: 'blackB.png' }, // black on transparent (square)
            { id: 'canvas11', textColor: '#FA660F', bgColor: 'transparent', badge: 'orangeB.png' }, // orange on transparent (square)
            { id: 'canvas12', textColor: '#FFFFFF', bgColor: 'transparent', badge: 'whiteB.png' }  // white on transparent (square)
        ];

        // Preload images
        const badgeImages = {
            'blackB.png': new Image(),
            'orangeB.png': new Image(),
            'whiteB.png': new Image()
        };
        badgeImages['blackB.png'].src = 'blackB.png';
        badgeImages['orangeB.png'].src = 'orangeB.png';
        badgeImages['whiteB.png'].src = 'whiteB.png';

        // Detect if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Detect iOS specifically
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        function generateLogos() {
            const input = document.getElementById('wordInput').value;
            const word = input ? input + "  " : ""; // Add two spaces only if there's input

            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) {
                    console.error(`Canvas with id ${canvasInfo.id} not found.`);
                    return; // Skip if canvas doesn't exist
                }
                const ctx = canvas.getContext('2d');

                // Clear canvas (transparent by default)
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Set background only for non-transparent canvases
                if (canvasInfo.bgColor !== 'transparent') {
                    ctx.fillStyle = canvasInfo.bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                if (word) {
                    // --- Dynamic Font Size Calculation ---
                    const maxWidth = canvas.width * 0.9;
                    const maxHeight = canvas.height * 0.9;
                    let fontSize = Math.min(canvas.width / 5, canvas.height / 1.5);
                    ctx.font = `bold ${fontSize}px Lexend`;
                    ctx.letterSpacing = `${fontSize * -0.1}px`;

                    let metrics = ctx.measureText(word);
                    let textWidth = metrics.width;
                    let textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                    textHeight = textHeight || fontSize; // Fallback

                    let iterations = 0;
                    const maxIterations = 100;

                    while (((textWidth > maxWidth) || (textHeight > maxHeight)) && fontSize > 10 && iterations < maxIterations) {
                        // More aggressive reduction if height is the limiter
                        let scaleFactor = Math.min(maxWidth / textWidth, maxHeight / textHeight);
                        fontSize *= scaleFactor * 0.98; // Reduce size proportionally, slight safety margin
                        fontSize = Math.max(fontSize, 10);
                        ctx.font = `bold ${fontSize}px Lexend`;
                        ctx.letterSpacing = `${fontSize * -0.1}px`;
                        metrics = ctx.measureText(word);
                        textWidth = metrics.width;
                        textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        textHeight = textHeight || fontSize;
                        iterations++;
                    }

                    iterations = 0;
                    while (textWidth < maxWidth * 0.8 && textHeight < maxHeight * 0.8 && fontSize < Math.min(canvas.width, canvas.height) && iterations < maxIterations) {
                         let scaleFactor = Math.min(maxWidth / textWidth, maxHeight / textHeight);
                         if (scaleFactor <= 1.02) break;
                         fontSize *= Math.min(scaleFactor, 1.05); // Less aggressive increase
                         fontSize = Math.min(fontSize, Math.min(canvas.width, canvas.height)); // Absolute cap
                         ctx.font = `bold ${fontSize}px Lexend`;
                         ctx.letterSpacing = `${fontSize * -0.1}px`;
                         metrics = ctx.measureText(word);
                         textWidth = metrics.width;
                         textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                         textHeight = textHeight || fontSize;
                         iterations++;
                    }

                    if (textWidth > maxWidth || textHeight > maxHeight) {
                         fontSize *= Math.min(maxWidth / textWidth, maxHeight / textHeight);
                         fontSize = Math.max(fontSize, 10);
                         ctx.font = `bold ${fontSize}px Lexend`;
                         ctx.letterSpacing = `${fontSize * -0.1}px`;
                         metrics = ctx.measureText(word); // Re-measure after final adjustment
                         textWidth = metrics.width;
                    }
                    // --- End Font Size Calculation ---

                    // Set text properties
                    ctx.fillStyle = canvasInfo.textColor;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; // Crucial for vertical centering

                    // Draw text in center
                    const textY = canvas.height / 2; // Baseline for middle alignment
                    ctx.fillText(word, canvas.width/2, textY);

                    // --- Badge Drawing ---
                    // Use a more consistent approach for badge positioning
                    const badgeHeight = fontSize * 0.6; // Badge height relative to font size
                    const badgeAspectRatio = 534 / 889; // Aspect ratio of badge image (width/height)
                    const badgeWidth = badgeHeight * badgeAspectRatio;

                    // Measure the input text *without* trailing spaces to find its end point
                    const inputMetrics = ctx.measureText(input); // Use 'input', not 'word'
                    const inputWidth = inputMetrics.width;

                    // Calculate X position:
                    // Start at canvas center, move to the right edge of the *centered input text*, then shift slightly left.
                    const badgeX = (canvas.width / 2) + (inputWidth / 2) - (fontSize * 0.12);

                    // *** FIXED Y POSITION CALCULATION FOR CROSS-PLATFORM CONSISTENCY ***
                    // Use the same positioning approach across all platforms
                    // Calculate vertical position based on font size, not text metrics which can vary
                    // Use a percentage of font size for a consistent appearance
                    
                    // Estimate the cap height (height of capital letters) as a fraction of font size
                    // This is more consistent across platforms than actualBoundingBox values
                    const capHeight = fontSize * 0.7; // Approximate cap height
                    
                    // Position badge to align its bottom with a point slightly above text center line
                    // This creates a more balanced appearance with badge near the top of the text
                    const badgeY = textY - (capHeight / 2) - (fontSize * 0.18);
                    
                    // Draw badge image
                    const badgeImg = badgeImages[canvasInfo.badge];
                    if (badgeImg.complete && badgeImg.naturalWidth > 0) { // Check if image loaded
                        try {
                            ctx.drawImage(badgeImg, badgeX, badgeY, badgeWidth, badgeHeight);
                        } catch (e) {
                            console.error("Error drawing badge image:", e);
                        }
                    } else if (!badgeImg.complete) {
                        badgeImg.onload = () => {
                            // Check if canvas still exists in DOM in case of rapid changes
                            if (document.getElementById(canvasInfo.id)) {
                                // Redraw *only this specific canvas* when its badge loads
                                // Avoid triggering a full regeneration if possible
                                // Simplified: just call generateLogos again, though less efficient
                                generateLogos();
                            }
                        }
                    }
                    // --- End Badge Drawing ---
                }
            });

            // Add click events after logos are generated
            setupCanvasClickEvents();
        }

        function setupCanvasClickEvents() {
            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) return; // Skip if canvas doesn't exist

                // Remove existing click event to avoid duplicates
                canvas.onclick = null;

                // Only add click handlers on mobile
                if (isMobile) {
                    canvas.onclick = () => {
                        const dataUrl = canvas.toDataURL('image/png');
                        const word = document.getElementById('wordInput').value || 'Logo';
                        // Include aspect ratio marker in filename for clarity
                        const aspectRatio = canvas.width === canvas.height ? 'square' : '16x9';
                        const filename = `${word}_${canvasInfo.textColor}_on_${canvasInfo.bgColor === 'transparent' ? 'transparent' : canvasInfo.bgColor}_${aspectRatio}.png`.replace('#',''); // Clean filename

                        // Special handling for iOS devices
                        if (isIOS && navigator.share) {
                           try {
                                fetch(dataUrl)
                                    .then(res => res.blob())
                                    .then(blob => {
                                        if (!blob) throw new Error("Failed to create blob");
                                        const file = new File([blob], filename, { type: 'image/png' });
                                        navigator.share({
                                            files: [file],
                                            title: filename
                                        }).catch((error) => {
                                            console.error('Share API failed:', error);
                                            // Fallback to opening in new tab for long-press save
                                            window.open(dataUrl, '_blank');
                                        });
                                    }).catch(error => {
                                        console.error('Fetch/Blob failed:', error);
                                         window.open(dataUrl, '_blank'); // Fallback
                                    });
                           } catch (error) {
                                console.error('Error preparing share data:', error);
                                window.open(dataUrl, '_blank'); // Fallback
                           }
                        } else if (isIOS) {
                            // Fallback for older iOS or if Share API fails initially: open in new tab
                             window.open(dataUrl, '_blank');
                        }
                        else {
                            // For Android and other mobile browsers
                            const link = document.createElement('a');
                            link.download = filename;
                            link.href = dataUrl;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        }
                    };
                }
                // No click handler on desktop
            });
        }

        function resizeCanvases() {
            const container = document.querySelector('.container');
            const totalWidth = Math.min(800, container.clientWidth);
            const gap = 10; // Match CSS gap
            const isSmallScreen = totalWidth <= 600;

            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) return;

                // Determine the display width for the canvas
                const displayWidth = isSmallScreen
                    ? totalWidth // Full width on small screens (CSS handles this mostly)
                    : (totalWidth - gap) / 2; // Half width minus gap on larger screens

                // Get native dimensions
                const nativeWidth = canvas.width;
                const nativeHeight = canvas.height;

                // Calculate display height based on native aspect ratio
                const displayHeight = (displayWidth * nativeHeight) / nativeWidth;

                // Set the style dimensions
                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;
            });

            // Regenerate logos after resizing styles
            generateLogos();
        }

        window.addEventListener('resize', resizeCanvases);
        window.addEventListener('load', () => {
             // Ensure images are loaded before first draw attempt if possible
             let loadedCount = 0;
             const totalImages = Object.keys(badgeImages).length;
             const tryInitialDraw = () => {
                loadedCount++;
                if (loadedCount >= totalImages) {
                    resizeCanvases(); // Call resize which calls generateLogos
                }
             }
             Object.values(badgeImages).forEach(img => {
                if (img.complete && img.naturalWidth > 0) { // Check if actually loaded
                    loadedCount++;
                } else {
                    img.onload = tryInitialDraw;
                    img.onerror = () => {
                         console.error(`Failed to load badge: ${img.src}`);
                         tryInitialDraw(); // Count errors too so it doesn't hang
                    }
                }
             });
             if (loadedCount >= totalImages) {
                 resizeCanvases(); // Draw immediately if all cached/loaded
             }
             // Add a fallback timeout in case onload never fires for some reason
             setTimeout(() => {
                if(loadedCount < totalImages) {
                    console.warn("Timeout waiting for images, attempting draw anyway.");
                    resizeCanvases();
                }
             }, 5000); // 5 second timeout
        });

    </script>
</body>
</html>