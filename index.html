<!DOCTYPE html>
<html>
<head>
    <title>Strategy Logo Maker</title>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* CSS styles remain the same */
        body { display: flex; flex-direction: column; align-items: center; font-family: 'Lexend', sans-serif; margin: 0; padding: 20px 20px 0; min-height: 100vh; box-sizing: border-box; background-color: #FFFFFF; }
        .container { width: 100%; max-width: 800px; display: flex; flex-direction: column; align-items: center; gap: 10px; flex-grow: 1; }
        h2 { font-size: 2.5em; font-weight: 700; margin: 0; color: #FA660F; letter-spacing: -0.1em; padding-bottom: 10px; text-align: center; }
        input { width: 100%; max-width: 300px; padding: 10px; font-size: 16px; font-family: 'Lexend', sans-serif; font-weight: 400; box-sizing: border-box; border: 3px solid transparent; border-radius: 8px; background: linear-gradient(#FFFFFF, #FFFFFF) padding-box, linear-gradient(to right, #FFB6C1, #FFDAB9, #FFDEAD, #E6E6FA, #B0E0E6, #98FB98, #D8BFD8) border-box; animation: gradientShift 8s linear infinite; background-size: 100% 100%, 200% 100%; }
        @keyframes gradientShift { 0% { background-position: 0% 0%; } 100% { background-position: 200% 0%; } }
        .canvas-row { display: flex; flex-wrap: nowrap; gap: 10px; width: 100%; max-width: 800px; justify-content: center; }
        canvas { border: 1px solid #ccc; display: block; }
        .transparent-bg { background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        footer { width: 100%; text-align: center; padding: 15px 0 10px 0; background-color: #FFFFFF; font-weight: 400; margin-top: auto; }
        footer a { color: #FA660F; text-decoration: none; }
        footer a b { font-weight: 700; }
        footer a:hover { text-decoration: underline; }
        @media (max-width: 810px) { .canvas-row { flex-direction: column; align-items: center; gap: 10px; } canvas { width: 100% !important; max-width: 390px; height: auto !important; cursor: pointer; } }
        @media (max-width: 600px) { h2 { font-size: 1.8em; } input { max-width: 100%; } }
    </style>
</head>
<body>
    <div class="container">
        <h2>Strategy Logo Maker</h2>
        <input type="text" id="wordInput" value="Logo" oninput="generateLogos()">
        <div class="canvas-row"> <canvas id="canvas1" width="1280" height="720"></canvas> <canvas id="canvas4" width="1280" height="720" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas2" width="1280" height="720"></canvas> <canvas id="canvas5" width="1280" height="720" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas3" width="1280" height="720"></canvas> <canvas id="canvas6" width="1280" height="720" class="transparent-bg"></canvas> </div>
    </div>
    <footer> Made by <a href="https://x.com/LaDoger21" target="_blank" rel="noopener noreferrer"><b>@LaDoger21</b></a> with ðŸ§¡ </footer>

    <script>
        const canvases = [
            { id: 'canvas1', textColor: '#000000', bgColor: '#FA660F', badge: 'blackB.png' },
            { id: 'canvas2', textColor: '#FA660F', bgColor: '#FFFFFF', badge: 'orangeB.png' },
            { id: 'canvas3', textColor: '#FFFFFF', bgColor: '#000000', badge: 'whiteB.png' },
            { id: 'canvas4', textColor: '#000000', bgColor: 'transparent', badge: 'blackB.png' },
            { id: 'canvas5', textColor: '#FA660F', bgColor: 'transparent', badge: 'orangeB.png' },
            { id: 'canvas6', textColor: '#FFFFFF', bgColor: 'transparent', badge: 'whiteB.png' }
        ];

        const badgeImages = {};
        let imagesLoaded = 0;
        const totalImages = 3;
        let initialDrawComplete = false;
        let generateTimeout;

        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages && !initialDrawComplete) {
                console.log("All badge images loaded initially.");
                requestAnimationFrame(generateLogos);
                initialDrawComplete = true;
            } else if (initialDrawComplete) {
                 requestAnimationFrame(generateLogos);
            }
        }

        ['blackB.png', 'orangeB.png', 'whiteB.png'].forEach(src => {
            if (!badgeImages[src]) {
                const img = new Image();
                img.onload = imageLoaded;
                img.onerror = () => { console.error("Failed to load badge image:", src); imageLoaded(); };
                img.src = src;
                badgeImages[src] = img;
            }
        });

        // --- Revised Browser Detection ---
        // Check for Safari, EXCLUDING Chrome/Android/CriOS/EdgiOS etc.
        const isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 &&
                       navigator.userAgent &&
                       navigator.userAgent.indexOf('CriOS') == -1 &&
                       navigator.userAgent.indexOf('FxiOS') == -1 &&
                       navigator.userAgent.indexOf('EdgiOS') == -1;

        // Use this check to determine if adjustment is needed
        const needsSpacingAdjustment = isSafari;
        // -------------------------------

        // Log the check result ONCE on load
        console.log("Initial needsSpacingAdjustment Check:", needsSpacingAdjustment, " User Agent:", navigator.userAgent);

        function generateLogos() {
            clearTimeout(generateTimeout);
            generateTimeout = setTimeout(() => {
                const inputText = document.getElementById('wordInput').value;
                const textToRender = inputText || "";

                if (!initialDrawComplete && imagesLoaded < totalImages) { return; }

                canvases.forEach(canvasInfo => {
                    const canvas = document.getElementById(canvasInfo.id);
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;

                    // Clear and Set Background
                    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    if (canvasInfo.bgColor !== 'transparent') {
                        ctx.fillStyle = canvasInfo.bgColor;
                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                    }

                     // --- Visual Check (Tied to *new* condition) ---
                     if (needsSpacingAdjustment) {
                         ctx.fillStyle = 'blue'; // Changed to blue to confirm change
                         ctx.fillRect(0, 0, 5, 5); // Draw tiny blue dot if adjustment needed
                     }
                     // -----------------------------------------

                    if (textToRender) {
                        const badgeImg = badgeImages[canvasInfo.badge];
                        let badgeWidth = 0, badgeHeight = 0, badgeGap = 0;
                        const badgeAspectRatio = (badgeImg && badgeImg.naturalWidth) ? (badgeImg.naturalWidth / badgeImg.naturalHeight) : (534 / 889);

                        // Font Size Calculation
                        const maxHeightConstraint = canvasHeight * 0.9;
                        let fontSize = Math.min(maxHeightConstraint, 400);

                        let finalMetrics, textWidth, totalVisualWidth, fontAscent, fontDescent;
                        let spacingString = '-0px';

                        while (fontSize > 10) {
                             ctx.font = `bold ${fontSize}px Lexend`;

                             // --- Explicit Spacing Calculation & Assignment ---
                             const desktopSpacingValue = fontSize * -0.1;
                             const adjustedSpacingValue = fontSize * -0.12; // Adjusted value for Safari (tune this!)
                             // Use the NEW condition here
                             const spacingValueToUse = needsSpacingAdjustment ? adjustedSpacingValue : desktopSpacingValue;
                             spacingString = `${spacingValueToUse}px`;

                             ctx.letterSpacing = spacingString;
                             // Log check inside loop is less critical now, but keeping it doesn't hurt
                             // console.log(`MEASURE LOOP (Canvas ${canvasInfo.id}): Adjust=${needsSpacingAdjustment}, Font=${fontSize}px, Spacing Str='${spacingString}'`);
                             // --- End Explicit Spacing ---

                             finalMetrics = ctx.measureText(textToRender);
                             textWidth = finalMetrics.width;

                             fontAscent = finalMetrics.actualBoundingBoxAscent || fontSize * 0.75;
                             fontDescent = finalMetrics.actualBoundingBoxDescent || fontSize * 0.25;
                             const textHeightApprox = fontAscent + fontDescent;

                             badgeHeight = fontSize * 0.6;
                             badgeWidth = badgeHeight * badgeAspectRatio;
                             badgeGap = fontSize * 0.08;
                             totalVisualWidth = textWidth + badgeGap + badgeWidth;

                             const maxWidthConstraint = canvasWidth * 0.90;

                             if (textHeightApprox <= maxHeightConstraint && totalVisualWidth <= maxWidthConstraint) { break; }
                             fontSize -= 5;
                        }
                        fontSize = Math.max(10, fontSize);

                        // Recalculate FINAL dimensions & metrics
                        ctx.font = `bold ${fontSize}px Lexend`;

                        // --- Apply FINAL Explicit Spacing ---
                        const finalDesktopSpacingValue = fontSize * -0.1;
                        const finalAdjustedSpacingValue = fontSize * -0.12; // Use same adjusted value (tune this!)
                        // Use the NEW condition here
                        const finalSpacingValueToUse = needsSpacingAdjustment ? finalAdjustedSpacingValue : finalDesktopSpacingValue;
                        const finalSpacingString = `${finalSpacingValueToUse}px`;

                        ctx.letterSpacing = finalSpacingString;
                        // console.log(`-- FINAL DRAW (Canvas ${canvasInfo.id}): Adjust=${needsSpacingAdjustment}, Font=${fontSize}px, Spacing Str='${finalSpacingString}'`);
                        // --- End Final Spacing ---

                        finalMetrics = ctx.measureText(textToRender);
                        textWidth = finalMetrics.width;
                        fontAscent = finalMetrics.actualBoundingBoxAscent || fontSize * 0.75;
                        fontDescent = finalMetrics.actualBoundingBoxDescent || fontSize * 0.25;
                        badgeHeight = fontSize * 0.6;
                        badgeWidth = badgeHeight * badgeAspectRatio;
                        badgeGap = fontSize * 0.08;
                        totalVisualWidth = textWidth + badgeGap + badgeWidth;

                         const xMetrics = ctx.measureText('x');
                         const xAscent = xMetrics.actualBoundingBoxAscent || fontSize * 0.5;

                        // Positioning & Rendering (unchanged logic)
                        const startX = (canvasWidth / 2) - (totalVisualWidth / 2);
                        const startY = canvasHeight / 2 + (fontAscent - fontDescent) / 2;
                        ctx.fillStyle = canvasInfo.textColor;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                        ctx.fillText(textToRender, startX, startY);
                        if (badgeImg && badgeImg.complete && badgeImg.naturalHeight !== 0) {
                            const badgeX = startX + textWidth + badgeGap;
                            const badgeY = startY - xAscent - (badgeHeight / 2);
                            ctx.drawImage(badgeImg, badgeX, badgeY, badgeWidth, badgeHeight);
                        }

                        // Reset context defaults
                        ctx.letterSpacing = '0px';
                        ctx.textAlign = 'start';
                    }
                });
                setupCanvasClickEvents();
            }, 16);
        }

        function setupCanvasClickEvents() { /* ... unchanged ... */
             canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                 if (!canvas) return;
                canvas.onclick = null;
                canvas.style.cursor = 'pointer';
                canvas.onclick = () => {
                    const dataUrl = canvas.toDataURL('image/png');
                    const word = document.getElementById('wordInput').value || 'Logo';
                    const filename = `${word.replace(/[^a-z0-9]/gi, '_')}_${canvasInfo.id}.png`;
                    const isIOSCheckForShare = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep specific iOS check just for navigator.share if needed
                    if (isIOSCheckForShare && navigator.share) { // Use specific check here
                        fetch(dataUrl).then(res => res.blob()).then(blob => {
                            const file = new File([blob], filename, { type: 'image/png' });
                            navigator.share({ files: [file], title: filename })
                                .catch((error) => { console.log('Share API failed:', error); const link = document.createElement('a'); link.href = dataUrl; link.download = filename; link.target = '_blank'; document.body.appendChild(link); link.click(); document.body.removeChild(link); });
                        });
                    } else {
                        const link = document.createElement('a'); link.download = filename; link.href = dataUrl; document.body.appendChild(link); link.click(); document.body.removeChild(link);
                    }
                };
            });
        }
        function resizeCanvases() { /* ... unchanged ... */
             const container = document.querySelector('.container'); if (!container) return;
             const containerWidth = container.clientWidth; const gap = 10; const isMobileLayout = window.innerWidth <= 810;
             const desktopCanvasWidth = Math.min(390, (containerWidth - gap) / 2);
            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id); if (!canvas) return;
                 let targetWidth = isMobileLayout ? Math.min(containerWidth, 390) : desktopCanvasWidth;
                canvas.style.width = `${targetWidth}px`; canvas.style.height = `${(targetWidth * 720) / 1280}px`;
            });
             if (imagesLoaded === totalImages || initialDrawComplete) { requestAnimationFrame(generateLogos); }
        }

        // Initial setup & Event Listeners
        window.addEventListener('resize', resizeCanvases);
        window.addEventListener('load', () => { console.log("Window loaded."); resizeCanvases(); document.fonts.ready.then(() => { console.log("Fonts ready."); requestAnimationFrame(generateLogos); }); });
        if (document.readyState === 'complete' || (document.readyState !== 'loading' && !document.documentElement.doScroll)) { resizeCanvases(); } else { document.addEventListener('DOMContentLoaded', resizeCanvases); }

    </script>
</body>
</html>