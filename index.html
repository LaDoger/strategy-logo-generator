<!DOCTYPE html>
<html>
<head>
    <title>Strategy Logo Maker</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Meta Tags -->
    <meta property="og:title" content="Strategy Logo Maker">
    <meta property="og:description" content="Strategy Logo Makers made by @LaDoger21">
    <meta property="og:type" content="gallery">
    <meta property="og:url" content="https://ladoger.art/logomaker">
    <meta property="og:image" content="https://ladoger.art/logomaker/logomaker.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="600">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Strategy Logo Maker">
    <meta name="twitter:description" content="Strategy Logo Maker made by @LaDoger21">
    <meta name="twitter:image" content="https://ladoger.art/logomaker/logomaker.jpg">
    <meta name="twitter:site" content="@LaDoger21">

    <style>
        :root {
            --input-height: 44px;
            --input-border-width: 3px;
            --input-padding: 10px;
            --border-radius: 8px;
            --standard-gap: 8px; /* Renamed for clarity */
        }
        body {
            display: flex; flex-direction: column; align-items: center;
            font-family: 'Lexend', sans-serif; margin: 0; padding: 20px 20px 0;
            min-height: 100vh; box-sizing: border-box; background-color: #FFFFFF;
        }
        .container {
            width: 100%; max-width: 800px; display: flex; flex-direction: column;
            align-items: center; gap: var(--standard-gap); flex-grow: 1;
        }
        h2 {
            font-size: 2.5em; font-weight: 700; margin: 0; color: #FA660F;
            letter-spacing: -0.1em; padding-bottom: 5px;
        }
        .animated-border {
            padding: var(--input-padding); box-sizing: border-box;
            border: var(--input-border-width) solid transparent;
            border-radius: var(--border-radius);
            background: linear-gradient(var(--bg-color, #FFFFFF), var(--bg-color, #FFFFFF)) padding-box,
                        linear-gradient(to right, #FFB6C1, #FFDAB9, #FFDEAD, #E6E6FA, #B0E0E6, #98FB98, #D8BFD8) border-box;
            animation: gradientShift 8s linear infinite; background-size: 100% 100%, 200% 100%;
            height: var(--input-height);
        }
        @keyframes gradientShift { 0% { background-position: 0% 0%, 0% 0%; } 100% { background-position: 0% 0%, 200% 0%; } }
        .text-input-wrapper {
             width: 100%; max-width: 300px; --bg-color: #FFFFFF; position: relative;
        }
        .text-input-wrapper input[type="text"] {
            width: 100%; height: 100%; background: transparent; border: none; outline: none;
            padding: 0 var(--input-padding); box-sizing: border-box;
            font-size: 16px; font-family: 'Lexend', sans-serif; font-weight: 400;
            text-align: center;
        }
        .color-picker-container {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; max-width: 300px; gap: var(--standard-gap);
        }
        .color-picker-label {
            flex: 1; display: block; position: relative; cursor: pointer;
            height: var(--input-height); padding: 0; min-width: 0;
        }
        .color-picker-label input[type="color"] {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; cursor: pointer; border: none; padding: 0; margin: 0;
        }
        .canvas-row { display: flex; flex-wrap: nowrap; gap: var(--standard-gap); width: 100%; max-width: 800px; }
        canvas { width: 390px; height: auto; border: 1px solid #ccc; display: block; }
        .transparent-bg {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        footer { width: 100%; text-align: center; padding: 10px 0; background-color: #FFFFFF; font-weight: 400; margin-top: var(--standard-gap); }
        footer a { color: #FA660F; text-decoration: none; } footer a b { font-weight: 700; } footer a:hover { text-decoration: underline; }

        @media (max-width: 600px) {
            h2 { font-size: 1.8em; }
            .text-input-wrapper, .color-picker-container { max-width: 100%; }
            .canvas-row { flex-direction: column; gap: var(--standard-gap); }
            canvas { width: 100% !important; max-width: 100%; cursor: pointer; }
        }
    </style>
</head>
<body>
    <div class="container" id="mainContainer">
        <h2>Strategy Logo Maker</h2>

        <div class="text-input-wrapper animated-border">
            <input type="text" id="wordInput" value="More" placeholder="Enter text..." oninput="generateLogos()">
        </div>

        <div class="color-picker-container">
            <!-- Default order: Black, Orange, White -->
            <label class="color-picker-label animated-border" id="labelPicker1">
                <input type="color" id="colorPicker1" value="#000000" title="Color 1 (Default Black)" oninput="handleColorInput(this)">
            </label>
            <label class="color-picker-label animated-border" id="labelPicker2">
                <input type="color" id="colorPicker2" value="#FA660F" title="Color 2 (Default Orange)" oninput="handleColorInput(this)">
            </label>
            <label class="color-picker-label animated-border" id="labelPicker3">
                <input type="color" id="colorPicker3" value="#FFFFFF" title="Color 3 (Default White)" oninput="handleColorInput(this)">
            </label>
        </div>

        <!-- Canvas Rows - Structure remains same -->
        <div class="canvas-row"> <canvas id="canvas1" width="1280" height="720"></canvas> <canvas id="canvas4" width="1280" height="720" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas2" width="1280" height="720"></canvas> <canvas id="canvas5" width="1280" height="720" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas3" width="1280" height="720"></canvas> <canvas id="canvas6" width="1280" height="720" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas7" width="1280" height="1280"></canvas> <canvas id="canvas10" width="1280" height="1280" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas8" width="1280" height="1280"></canvas> <canvas id="canvas11" width="1280" height="1280" class="transparent-bg"></canvas> </div>
        <div class="canvas-row"> <canvas id="canvas9" width="1280" height="1280"></canvas> <canvas id="canvas12" width="1280" height="1280" class="transparent-bg"></canvas> </div>
    </div>
    <footer> Made by <a href="https://x.com/LaDoger21"><b>@LaDoger21</b></a> with ðŸ§¡ </footer>

    <script>
        // Color Roles now conceptually match the default picker order:
        const COLOR_ROLE_1 = 'color1'; // Default Black (Picker 1)
        const COLOR_ROLE_2 = 'color2'; // Default Orange (Picker 2)
        const COLOR_ROLE_3 = 'color3'; // Default White (Picker 3)

        // ** UPDATED Canvas Definitions **
        // Uses roles based on the new default picker meanings
        const canvases = [
            // Desired Order: Black-on-Orange, Orange-on-White, White-on-Black
            { id: 'canvas1', textColorRole: COLOR_ROLE_1, bgColorRole: COLOR_ROLE_2 }, // Txt=R1(Black), BG=R2(Orange)
            { id: 'canvas2', textColorRole: COLOR_ROLE_2, bgColorRole: COLOR_ROLE_3 }, // Txt=R2(Orange), BG=R3(White)
            { id: 'canvas3', textColorRole: COLOR_ROLE_3, bgColorRole: COLOR_ROLE_1 }, // Txt=R3(White), BG=R1(Black)
            // Transparent versions follow text color order: Black, Orange, White
            { id: 'canvas4', textColorRole: COLOR_ROLE_1, bgColorRole: 'transparent' }, // Txt=R1(Black)
            { id: 'canvas5', textColorRole: COLOR_ROLE_2, bgColorRole: 'transparent' }, // Txt=R2(Orange)
            { id: 'canvas6', textColorRole: COLOR_ROLE_3, bgColorRole: 'transparent' }, // Txt=R3(White)
            // Square versions mirror the above logic
            { id: 'canvas7', textColorRole: COLOR_ROLE_1, bgColorRole: COLOR_ROLE_2 }, // Txt=R1(Black), BG=R2(Orange)
            { id: 'canvas8', textColorRole: COLOR_ROLE_2, bgColorRole: COLOR_ROLE_3 }, // Txt=R2(Orange), BG=R3(White)
            { id: 'canvas9', textColorRole: COLOR_ROLE_3, bgColorRole: COLOR_ROLE_1 }, // Txt=R3(White), BG=R1(Black)
            { id: 'canvas10', textColorRole: COLOR_ROLE_1, bgColorRole: 'transparent' },// Txt=R1(Black)
            { id: 'canvas11', textColorRole: COLOR_ROLE_2, bgColorRole: 'transparent' },// Txt=R2(Orange)
            { id: 'canvas12', textColorRole: COLOR_ROLE_3, bgColorRole: 'transparent' } // Txt=R3(White)
        ];

        const symbolImg = new Image();
        symbolImg.src = 'symbol.png';
        let symbolLoaded = false;
        symbolImg.onload = () => { symbolLoaded = true; if (window.initialDrawTriggered) generateLogos(); };
        symbolImg.onerror = () => console.error("Failed to load symbol.png");

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const isMobile = () => window.innerWidth <= 600;
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const mainContainer = document.getElementById('mainContainer'); // Cache container

        // --- Helper Functions (Unchanged) ---
        function getSelectedColors() {
            return {
                [COLOR_ROLE_1]: document.getElementById('colorPicker1').value,
                [COLOR_ROLE_2]: document.getElementById('colorPicker2').value,
                [COLOR_ROLE_3]: document.getElementById('colorPicker3').value
            };
         }
        function drawColorizedSymbol(mainCtx, targetColor, symbolX, symbolY, symbolWidth, symbolHeight) {
             if (!symbolLoaded || symbolWidth <= 0 || symbolHeight <= 0) return;
             try {
                 offscreenCanvas.width = symbolWidth; offscreenCanvas.height = symbolHeight;
                 offscreenCtx.clearRect(0, 0, symbolWidth, symbolHeight);
                 offscreenCtx.drawImage(symbolImg, 0, 0, symbolWidth, symbolHeight);
                 offscreenCtx.globalCompositeOperation = 'source-in';
                 offscreenCtx.fillStyle = targetColor;
                 offscreenCtx.fillRect(0, 0, symbolWidth, symbolHeight);
                 offscreenCtx.globalCompositeOperation = 'source-over';
                 mainCtx.drawImage(offscreenCanvas, symbolX, symbolY, symbolWidth, symbolHeight);
             } catch (e) { console.error("Error drawing symbol:", e); }
        }
        function updatePickerBackgrounds() {
            const colors = getSelectedColors();
            document.getElementById('labelPicker1').style.setProperty('--bg-color', colors[COLOR_ROLE_1]);
            document.getElementById('labelPicker2').style.setProperty('--bg-color', colors[COLOR_ROLE_2]);
            document.getElementById('labelPicker3').style.setProperty('--bg-color', colors[COLOR_ROLE_3]);
         }
        function handleColorInput(inputElement) {
            updatePickerBackgrounds();
            generateLogos();
         }

        // --- Logo Generation (Unchanged logic, uses updated canvas definitions) ---
        function generateLogos() {
            if (!symbolLoaded && !symbolImg.complete) { window.initialDrawTriggered = true; return; }
            requestAnimationFrame(() => {
                const input = document.getElementById('wordInput').value; const word = input ? input + "  " : "";
                const selectedColors = getSelectedColors();
                canvases.forEach(canvasInfo => {
                    const canvas = document.getElementById(canvasInfo.id); if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    const textColor = selectedColors[canvasInfo.textColorRole]; // Uses updated role assignments
                    const bgColor = canvasInfo.bgColorRole === 'transparent' ? 'transparent' : selectedColors[canvasInfo.bgColorRole]; // Uses updated role assignments
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (bgColor !== 'transparent') { ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                    if (word) {
                        const maxWidth = canvas.width * 0.9; const maxHeight = canvas.height * 0.9; let fontSize = Math.min(canvas.width / 5, canvas.height / 1.5);
                        let metrics, textWidth, textHeight, iterations; const maxIterations = 50;
                        const setFont = (size) => { ctx.font = `bold ${size}px Lexend`; ctx.letterSpacing = `${size * -0.1}px`; metrics = ctx.measureText(word); textWidth = metrics.width; textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent || size; };
                        setFont(fontSize); iterations = 0;
                        while (((textWidth > maxWidth) || (textHeight > maxHeight)) && fontSize > 10 && iterations < maxIterations) { fontSize *= Math.min(maxWidth / textWidth, maxHeight / textHeight) * 0.97; fontSize = Math.max(fontSize, 10); setFont(fontSize); iterations++; }
                        iterations = 0;
                        while (textWidth < maxWidth * 0.8 && textHeight < maxHeight * 0.8 && fontSize < Math.min(canvas.width, canvas.height) && iterations < maxIterations) { let scaleFactor = Math.min(maxWidth / textWidth, maxHeight / textHeight); if (scaleFactor <= 1.01) break; fontSize *= Math.min(scaleFactor, 1.02); fontSize = Math.min(fontSize, Math.min(canvas.width, canvas.height)); setFont(fontSize); iterations++; }
                        if (textWidth > maxWidth || textHeight > maxHeight) { fontSize *= Math.min(maxWidth / textWidth, maxHeight / textHeight); fontSize = Math.max(fontSize, 10); setFont(fontSize); }
                        ctx.fillStyle = textColor; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const textY = canvas.height / 2; ctx.fillText(word, canvas.width / 2, textY);
                        const symbolHeight = fontSize * 0.6; const symbolAspectRatio = 534 / 889; const symbolWidth = symbolHeight * symbolAspectRatio;
                        const inputMetrics = ctx.measureText(input); const inputWidth = inputMetrics.width; const symbolX = (canvas.width / 2) + (inputWidth / 2) - (fontSize * 0.12);
                        const downwardShiftFactor = 0.08; const symbolBottomY = textY + (fontSize * downwardShiftFactor); const symbolY = symbolBottomY - symbolHeight;
                        drawColorizedSymbol(ctx, textColor, symbolX, symbolY, symbolWidth, symbolHeight);
                    }
                });
            });
        }

        // --- Canvas Click Events (Unchanged) ---
        function setupCanvasClickEvents() {
             canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas || !isMobile()) return;
                canvas.onclick = () => {
                    const dataUrl = canvas.toDataURL('image/png'); const word = document.getElementById('wordInput').value || 'Logo';
                    const aspectRatio = canvas.width === canvas.height ? 'square' : '16x9'; const selectedColors = getSelectedColors();
                    const textColor = selectedColors[canvasInfo.textColorRole]; const bgColor = canvasInfo.bgColorRole === 'transparent' ? 'transparent' : selectedColors[canvasInfo.bgColorRole];
                    const filename = `${word}_${textColor}_on_${bgColor}_${aspectRatio}.png`.replace(/#/g,'');
                    if (isIOS && navigator.share) { fetch(dataUrl).then(res => res.blob()).then(blob => { if (!blob) throw new Error("Blob failed"); navigator.share({ files: [new File([blob], filename, { type: 'image/png' })], title: filename }).catch(() => window.open(dataUrl, '_blank')); }).catch(() => window.open(dataUrl, '_blank')); }
                    else if (isIOS) { window.open(dataUrl, '_blank'); }
                    else { const link = document.createElement('a'); link.download = filename; link.href = dataUrl; document.body.appendChild(link); link.click(); document.body.removeChild(link); }
                };
            });
        }

        // --- Resize Handling (Unchanged) ---
        function resizeHandler() {
            const container = mainContainer; const totalWidth = Math.min(800, container.clientWidth);
            const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--standard-gap')) || 8;
            const smallScreen = isMobile();
            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id); if (!canvas) return;
                const canvasRow = canvas.closest('.canvas-row'); if (!canvasRow) return;
                const displayStyle = window.getComputedStyle(canvasRow).display; if (displayStyle === 'none') canvasRow.style.display = 'flex';
                const canvasContainerWidth = smallScreen ? container.clientWidth : (totalWidth - gap) / 2;
                const displayWidth = Math.max(10, canvasContainerWidth);
                const nativeRatio = canvas.height / canvas.width; const displayHeight = displayWidth * nativeRatio;
                canvas.style.width = `${displayWidth}px`; canvas.style.height = `${displayHeight}px`;
                if (displayStyle === 'none') canvasRow.style.display = displayStyle;
            });
            updatePickerBackgrounds();
            generateLogos();
            setupCanvasClickEvents();
        }

        // --- Initial Setup (Unchanged) ---
        window.initialDrawTriggered = false;
        window.addEventListener('load', () => {
            if (symbolImg.complete && symbolImg.naturalWidth > 0) symbolLoaded = true;
            window.initialDrawTriggered = true;
            updatePickerBackgrounds();
            resizeHandler();
            let resizeTimeout;
            window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeHandler, 150); });
            setTimeout(() => { if(!symbolLoaded) { console.warn("Timeout waiting for symbol."); symbolLoaded = true; generateLogos(); } }, 3000);
        });

    </script>
</body>
</html>